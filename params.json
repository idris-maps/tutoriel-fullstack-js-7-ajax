{
  "name": "Tutoriel-fullstack-js-7-ajax",
  "tagline": "Tutoriel Fullstack JavaScript - Chapitre 7 - AJAX",
  "body": "# AJAX\r\n\r\n[AJAX](https://fr.wikipedia.org/wiki/Ajax_%28informatique%29) est une architecture où le client demande et envoit des données au serveur. L'acronyme signifie \"Asynchronous JavaScript and XML\". Malgré le nom, cette manière de faire permet aussi d'envoyer et de recevoir des données au format [JSON](https://fr.wikipedia.org/wiki/JavaScript_Object_Notation), pas uniquement du [XML](https://fr.wikipedia.org/wiki/Extensible_Markup_Language). Pour faire simple, AJAX est ce qui permettera à nos clients de communiquer avec le serveur REST du chapitre précédant.\r\n\r\nDupliquez le dossier ```6.serveur``` et appelez-le ```7.ajax```.\r\n\r\nCréez un dossier ```clients``` dans ```lib``` où nous mettrons les scriptes pour construire les clients. \r\n\r\n## Riot\r\n\r\n### Mise en place\r\n\r\nCréez un fichier ```riot``` dans ```lib/clients```\r\n\r\nCopiez les fichiers suivants du dossier ```4.riot``` du [chapitre 4](link_to_do) vers ```7.ajax```\r\n\r\n* ```4.riot/main.js``` > ```7.ajax/lib/clients/riot/main.js```\r\n* ```4.riot/lib``` > ```7.ajax/lib/clients/riot/lib```\r\n* ```4.riot/public/index.html``` > ```7.ajax/public/riot/index.html```\r\n* ```4.riot/public/style.css``` > ```7.ajax/public/riot/style.css```\r\n\r\nNous ne prenons ni ```package.json``` ni ```node_modules```. Puisque nous sommes dans un nouveau projet ```7.ajax```. Nous allons à nouveau télécharger les librairies nécessaires.\r\n\r\nDans ```7.ajax``` ouvrez le terminal.\r\n\r\n```\r\n$ npm install handlebars browserify-handlebars --save-dev\r\n```\r\n\r\n```--save-dev``` veut dire que nous n'avons besoin de ces librairies que pour créer le client et non pour faire tourner le serveur. Si quelqu'un télécharge le serveur mais ne veut pas modifier les clients, il pourra lancer ```npm install``` pour ne télécharger que les scriptes utiles au fonctionnement du serveur.\r\n\r\nDans ```6.serveur/package.json``` ajoutons les scriptes ```watch-riot``` et ```build-riot```.\r\n\r\n```\r\n\"watch-riot\": \"watchify lib/clients/riot/main.js -o public/riot/script.js -t riotify\",\r\n\"build-riot\": \"browserify lib/clients/riot/main.js -o public/riot/script.js -t riotify | minify public/riot/script.js -o public/riot/script.js\"\r\n```\r\n\r\nDans le terminal lancez ```watch-riot```:\r\n\r\n```\r\n$ npm run watch-riot\r\n```\r\n\r\nSi le fichier ```public/riot/script.js``` est créé, nous sommes prêts à ajouter AJAX au client.\r\n\r\nDémarrez le serveur dans une autre fenêtre du terminal.\r\n\r\n```\r\n$ node serveur\r\n```\r\n\r\nEt ouvrez la page dans le navigateur à cette adresse: http://localhost:3000/riot/\r\n\r\n## AJAX en javascript pure\r\n\r\nIl existe beaucoup de librairies qui nous permettent d'utiliser AJAX mais pour rester dans l'esprit de cet exercice, nous allons l'écrire nous même. \r\n\r\nCréez un fichier ```ajax.js``` dans ```lib/clients/riot/lib```.\r\n\r\n```\r\n// pour faire une requête GET\r\nexports.get = function(url, callback) {\r\n\r\n// une instance XMLHttpRequest()\r\n var request = new XMLHttpRequest()\r\n\r\n// le type de requête et l'URL\r\n request.open('GET', url, true)\r\n\r\n// ce qu'il faut faire avec la réponse\r\n request.onload = function() {\r\n\r\n// s'il n'y a pas de problème\r\n   if (request.status >= 200 && request.status < 400) {\r\n\r\n// la fonction de rappel envoit un premier argument \"err\" null et un deuxième argument avec les données\r\n     var data = JSON.parse(request.responseText)\r\n     callback(null, data)\r\n\r\n// si nous avons connecté au serveur mais celui-ci nous renvoit une erreur\r\n   } else {\r\n    callback('erreur dans la requête GET à l\\'URL ' + url)\r\n   }\r\n }\r\n\r\n// si nous n'arrivons pas à atteindre le serveur\r\n request.onerror = function() {\r\n  callback('le serveur ne répond pas à l'\\URL ' + url)\r\n }\r\n\r\n// envoyer la requête\r\n request.send()\r\n}\r\n\r\n// pour faire une requête POST\r\nexports.post = function(url, data, callback) {\r\n var request = new XMLHttpRequest()\r\n request.open('POST', url, true)\r\n request.setRequestHeader('Content-type', 'application/json; charset=utf-8')\r\n request.onreadystatechange = function () { \r\n  if(request.readyState == 4 && request.status == 200) {\r\n   var json = JSON.parse(request.responseText)\r\n   callback(null, json)\r\n  } else {\r\n   callback('Could not post to server')\r\n  }\r\n }\r\n\r\n// la seule différence avec GET est que nous envoyons des données au serveur\r\n request.send(JSON.stringify(data))\r\n}\r\n```\r\n\r\nNous allons maintenant ouvrir ```lib/clients/riot/lib/Modele-a-faire.js``` pour que le modèle aille chercher et modifie les données sur le serveur.\r\n\r\nLes changements sont commentés.\r\n\r\n```\r\nvar Event = require('events')\r\nvar ajax = require('./ajax') // lien vers ajax.js\r\n\r\nmodule.exports = function() {\r\n var ctx = this\r\n ctx.evt = new Event\r\n ctx.data = [] // vider le dictionnaire \"data\"\r\n\r\n// une méthode \"charger\" pour charger les données au lancement de l'application\r\n ctx.charger = function(callback) {\r\n  ajax.get('/api/a-faire', function(err,data) {\r\n   if(err) { console.log(err) }\r\n   else { ctx.data = data }\r\n   callback()\r\n  })\r\n }\r\n\r\n ctx.ajouter = function(text) {\r\n\r\n// POST un objet \"aAjouter\" et émettre \"ajout\" quand le serveur a répondu\r\n  var aAjouter = {text: text, fait: false}\r\n  ajax.post('/api/a-faire', aAjouter, function(err,data) {\r\n   if(err) { console.log(err) }\r\n   else { ctx.data = data }\r\n    ctx.evt.emit('ajout')\r\n  })\r\n }\r\n\r\n ctx.basculerFait = function(index) {\r\n  if(ctx.data[index].fait) { ctx.data[index].fait = false }\r\n  else { ctx.data[index].fait = true }\r\n  maj(ctx.data[index]) // mettre à jour sur le serveur, voir fonction plus bas\r\n }\r\n\r\n ctx.mettreAJour = function(index, text) {\r\n  ctx.data[index].text = text\r\n  maj(ctx.data[index]) // mettre à jour sur le serveur, voir fonction plus bas\r\n }\r\n\r\n ctx.supprimerFait = function() {\r\n  var aGarder = []\r\n  var idsAsupprimer = [] // dictionnaire d'ID à supprimer\r\n  ctx.data.forEach(function(element) {\r\n   if(!element.fait) { aGarder.push(element) }\r\n   else { idsAsupprimer.push(element.id) }\r\n  })\r\n  ctx.data = aGarder\r\n\r\n// POST les IDs à supprimer\r\n  ajax.post('/api/a-faire/supprimer', idsAsupprimer, function(err,data) {\r\n   if(err) { console.log(err) }\r\n   else { ctx.data = data }\r\n   ctx.evt.emit('suppression')\r\n  })\r\n }\r\n}\r\n\r\n// fonction pour POSTer les mises à jour\r\nfunction maj(element) {\r\n ajax.post('/api/a-faire/maj', element)\r\n}\r\n```\r\n\r\nLors du chargement de la page, il faut aller chercher les données sur le serveur avec la méthode ```.charger()```.\r\n\r\nOuvrez ```lib/clients/riot/main.js```\r\n\r\n```\r\nvar riot = require('riot')\r\nvar Modele = require('./lib/Modele-a-faire')\r\nvar aFaireListe = require('./lib/composants/a-faire-liste.tag')\r\nvar aFaireFormulaire = require('./lib/composants/a-faire-formulaire.tag')\r\n\r\nvar modele = new Modele\r\n\r\nmodele.charger(function() { // <- nouveau\r\n riot.mount('a-faire-liste', modele)\r\n riot.mount('a-faire-formulaire', modele)\r\n}) // <- nouveau\r\n```\r\n\r\nSi le serveur et le scripte ```watch-riot``` tournent encore sans afficher d'erreurs, revisitez la page dans le navigateur. Rien ne s'affiche, c'est normal nous n'avons rien \"à faire\" dans la base de données. Ajoutez quelque chose.\r\n\r\nEn testant l'application, jetez un coup d'oeil aux requêtes AJAX que fait le navigateur. Dans Firefox, c'est la commande clavier ```Ctrl-Shift-Q```. Vous allez voir les requêtes GET et POST effectuées.\r\n\r\nArrêtez le scripte ```watch-riot``` et créez l'application en lançant:\r\n\r\n```\r\n$ npm run build-riot\r\n```\r\n\r\n## Angular\r\n\r\nPour Angular nous allons utiliser la méthode ```$http```.\r\n\r\n### Mise en place\r\n\r\nCopiez les fichiers de ```5.angular``` vers ```7.ajax```\r\n\r\n* ```5.angular/main.js``` > ```7.ajax/lib/clients/angular/main.js```\r\n* ```5.angular/public/index.html``` > ```7.ajax/public/angular/index.html```\r\n* ```5.angular/public/style.css``` > ```7.ajax/public/angular/style.css```\r\n\r\nInstallez angular\r\n\r\n```\r\n$ npm install angular --save-dev\r\n```\r\n\r\nAjoutez les scriptes ```watch-angular``` et ```build-angular``` à ```package.json```\r\n\r\n```\r\n\"watch-angular\": \"watchify lib/clients/angular/main.js -o public/angular/script.js\",\r\n\"build-angular\": \"browserify lib/clients/angular/main.js -o public/angular/script.js | minify public/angular/script.js -o public/angular/script.js\"\r\n```\r\n\r\nLancez ```watch-angular```.\r\n\r\n### $http\r\n\r\nOuvrez ```main.js```\r\n\r\nDans angular, ```$http``` s'occupe des requêtes AJAX. Il faut l'ajouter comme argument de la fonction dans ```.controller()``` pour pouvoir l'utiliser.\r\n\r\nLes nouveautés sont commentées.\r\n\r\n```\r\nvar angular = require('angular')\r\nvar app = angular.module('aFaire', [])\r\n\r\nfunction aFaireCtrl($scope, $http) { // ajouter $http comme argument de la fonction\r\n\r\n// vider le dictionnaire\r\n $scope.data = [] \r\n\r\n// charger les données du serveur\r\n $http.get('/api/a-faire').success(function(data) {\r\n  $scope.data = data\r\n })\r\n\r\n $scope.ajouter = function() {\r\n  if($scope.nouveau) {\r\n   var aAjouter = {text: $scope.nouveau, fait: false} // un objet \"aAjouter\"\r\n   $http.post('/api/a-faire', aAjouter) // POSTer\r\n    .success(function(data) { $scope.data = data }) // en cas de succès\r\n    .error(function(err) { console.log(err) }) // s'il y a une erreur\r\n  }\r\n }\r\n\r\n $scope.supprimerFait = function() {\r\n  var idsAsupprimer = [] // dictionnaire d'IDs à supprimer\r\n  $scope.data.forEach(function(o) {\r\n   if(o.fait) { idsAsupprimer.push(o.id) } // si fait mettre l'ID dans \"idsAsupprimer\"\r\n  })\r\n  $http.post('/api/a-faire/supprimer', idsAsupprimer) // POSTer les IDs\r\n   .success(function(data) { $scope.data = data }) // en cas de succès\r\n   .error(function(err) { console.log(err) }) // s'il y a une erreur\r\n }\r\n\r\n $scope.basculerFait = function(index) {\r\n  if($scope.data[index].fait) {\r\n   $scope.data[index].fait = false\r\n  } else {\r\n   $scope.data[index].fait = true\r\n  }\r\n  maj($scope, $http, $scope.data[index]) // mettre à jour sur le serveur (voir fonction plus bas)\r\n }\r\n\r\n $scope.basculerMaj = function(index) {\r\n  if($scope.data[index].maj) { $scope.data[index].maj = undefined }\r\n  else {\r\n   $scope.data.forEach(function(o) { if(o.maj) { o.maj = undefined } })\r\n   $scope.data[index].maj = true\r\n  }\r\n }\r\n\r\n $scope.mettreAJour = function(index) {\r\n  if(this.nouveauText) {\r\n   $scope.data[index].text = this.nouveauText\r\n   maj($scope, $http, $scope.data[index]) // mettre à jour sur le serveur (voir fonction plus bas)\r\n   $scope.data[index].maj = undefined\r\n   this.nouveauText = ''\r\n  }\r\n }\r\n}\r\n\r\n// injecter aussi $http avec $inject\r\naFaireCtrl.$inject = ['$scope', '$http']\r\n\r\n// passer $http au contrôleur\r\napp.controller('aFaireCtrl', ['$scope', '$http', aFaireCtrl])\r\n\r\n// fonction de mise à jour\r\nfunction maj($scope, $http, element) {\r\n $http.post('/api/a-faire/maj', element)\r\n  .success(function(data) { $scope.data = data })\r\n  .error(function(err) { console.log(err) })\r\n} \r\n```\r\n\r\nSi l'application fonctionne, arrêtez ```watch-angular``` et lancez ```build-angular```.\r\n\r\n```\r\n$ npm run build-angular\r\n```\r\n\r\n# FIN\r\n\r\nDans ce tutoriel nous avons vu comment créer des applications de type MVC avec javascript. En commençant par tout faire nous-même pour comprendre ce qui se passe. Puis en ajoutant des scriptes externes pour nous faciliter la vie. Nous avons rapidement vu comment créer un serveur avec Express qui sert des données via une API REST et des fichiers. Finalement, dans ce chapiter, nous avons avons modifié deux clients pour qu'ils communiquent avec l'API REST par le biais de requêtes AJAX.\r\n\r\nNotre application \"A faire\" est excessivement simpliste et n'est pas d'une grande utilité. Mais j'espère que vous avez maintenant vu les bases qui vous permetterons de créer des applications plus ambitieuses.\r\n\r\n<img src=\"https://avatars3.githubusercontent.com/u/12154856\" alt=\"Idris maps\">\r\n\r\nhttp://www.idris-maps.com\r\n\r\nSi vous avez aimé ce tutoriel et souhaitez m'employer, vous pouvez me contacter à ```idris.maps(a)gmx(point)ch```\r\n\r\n",
  "note": "Don't delete this file! It's used internally to help with page regeneration."
}